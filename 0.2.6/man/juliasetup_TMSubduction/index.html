<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example 3: Subduction · LaMEM.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LaMEM.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Installation</span><ul><li><a class="tocitem" href="../installation/">General instructions</a></li><li><a class="tocitem" href="../installation_HPC/">Installation on HPC systems</a></li></ul></li><li><span class="tocitem">Create &amp; run LaMEM models from julia</span><ul><li><a class="tocitem" href="../juliasetups/">Overview</a></li><li><a class="tocitem" href="../juliasetup_example_sphere/">Example 1: Sphere</a></li><li><a class="tocitem" href="../juliasetup_LaPalma/">Example 2: Volcano</a></li><li class="is-active"><a class="tocitem" href>Example 3: Subduction</a></li><li><a class="tocitem" href="../juliasetup_pluto/">Notebooks</a></li><li><a class="tocitem" href="../LaMEM_ModelFunctions/">Available functions</a></li></ul></li><li><a class="tocitem" href="../runlamem/">Run LaMEM</a></li><li><a class="tocitem" href="../readtimesteps/">Reading timesteps</a></li><li><a class="tocitem" href="../listfunctions/">List of functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Create &amp; run LaMEM models from julia</a></li><li class="is-active"><a href>Example 3: Subduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example 3: Subduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGeodynamics/LaMEM.jl/blob/main/docs/src/man/juliasetup_TMSubduction.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="D-Thermomechanical-subduction-model"><a class="docs-heading-anchor" href="#D-Thermomechanical-subduction-model">2D Thermomechanical subduction model</a><a id="D-Thermomechanical-subduction-model-1"></a><a class="docs-heading-anchor-permalink" href="#D-Thermomechanical-subduction-model" title="Permalink"></a></h1><p>In this example, we will show how to create a 2D thermomechanical model of subduction. Here the setup is saved into a julia script. First create a textfile called <code>TM_Subduction_example.jl</code> in your current directory. The easiest is to use <a href="https://code.visualstudio.com">Visual Studio Code</a> for this, but you can in principle use any text editor.</p><h4 id=".-Load-necessary-packages"><a class="docs-heading-anchor" href="#.-Load-necessary-packages">1. Load necessary packages</a><a id=".-Load-necessary-packages-1"></a><a class="docs-heading-anchor-permalink" href="#.-Load-necessary-packages" title="Permalink"></a></h4><p>Next start julia in the directory where you saved <code>TM_Subduction_example.jl</code>, or go to correct directory within julia  </p><p>Note that you can do the following steps directy from the julia <code>REPL</code> (command prompt), or you can write them in  <code>TM_Subduction_example.jl</code> and run that file by typing</p><pre><code class="language-julia hljs">julia&gt; include(&quot;TM_Subduction_example.jl&quot;)</code></pre><p>We get started by loading the required packages:</p><pre><code class="nohighlight hljs">using LaMEM, GeophysicalModelGenerator, Plots</code></pre><h4 id=".-LaMEM-model-setup"><a class="docs-heading-anchor" href="#.-LaMEM-model-setup">2. LaMEM model setup</a><a id=".-LaMEM-model-setup-1"></a><a class="docs-heading-anchor-permalink" href="#.-LaMEM-model-setup" title="Permalink"></a></h4><p>The setup will include 6 different materials with the following ID&#39;s:</p><pre><code class="nohighlight hljs"># material id&#39;s
# 0: asthenosphere
# 1: oceanic crust
# 2: oceanic lithosphere
# 3: continental crust
# 4: continental lithosphere
# 5: air layer</code></pre><pre><code class="nohighlight hljs">model = Model(Grid( x   = [-2000.,2000.],
                    y   = [-2.5,2.5],                 # &lt;- model is 2D, size in y-direction is choosen to be close to a cube shape for the cell
                    z   = [-660,40] ,
                    nel = (512,1,128)     ),

                    BoundaryConditions( temp_bot        = 1565.0,
                                        temp_top        = 20.0,
                                        open_top_bound  = 1),
                    Scaling(GEO_units(  temperature     = 1000,
                                        stress          = 1e9Pa,
                                        length          = 1km,
                                        viscosity       = 1e20Pa*s) ),
                    Time(nstep_max=20) )  </code></pre><p>This initializes the initial LaMEM model setup with a number of default options. On the <code>REPL</code> it will show the following info</p><pre><code class="language-julia hljs">LaMEM Model setup
|
|-- Scaling             :  GeoParams.Units.GeoUnits{GEO}
|-- Grid                :  nel=(512, 1, 128); xϵ(-2000.0, 2000.0), yϵ(-8.0, 8.0), zϵ(-660.0, 40.0) 
|-- Time                :  nstep_max=20; nstep_out=1; time_end=1.0; dt=0.05
|-- Boundary conditions :  noslip=[0, 0, 0, 0, 0, 0]
|-- Solution parameters :  eta_min=1.0e18; eta_max=1.0e25; eta_ref=1.0e20; act_temp_diff=0
|-- Solver options      :  direct solver; superlu_dist; penalty term=10000.0
|-- Model setup options :  Type=files; 
|-- Output options      :  filename=output; pvd=1; avd=0; surf=0
|-- Materials           :  0 phases; </code></pre><p>In this case we assume that we have dimensions in kilometers and times in million years (the default).</p><h5 id="Inspecting/modifying-parameters"><a class="docs-heading-anchor" href="#Inspecting/modifying-parameters">Inspecting/modifying parameters</a><a id="Inspecting/modifying-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting/modifying-parameters" title="Permalink"></a></h5><p>Each of the parameters in this model setup can be modified. The easiest way to see what is available is by using the <code>REPL</code>. If you type </p><pre><code class="language-julia hljs">julia&gt; model.</code></pre><p>and now use your <code>TAB</code> button, you will see all the fields within the <code>model</code> structure:</p><pre><code class="language-julia hljs">julia&gt; model.
BoundaryConditions  FreeSurface         Grid                Materials           ModelSetup          Output              Scaling             SolutionParams
Solver              Time</code></pre><p>If you want to see which timestepping parameters are set, you type:</p><pre><code class="nohighlight hljs">julia&gt; model.Time
LaMEM Timestepping parameters: 
  time_end        = 1.0 
  dt              = 0.05 
  dt_min          = 0.01 
  dt_max          = 0.2 
  dt_out          = 0.2 
  inc_dt          = 0.1 
  CFL             = 0.5 
  CFLMAX          = 0.8 
  nstep_max       = 20 
  nstep_out       = 1 
  nstep_rdb       = 100 
  nstep_ini       = 1 
  time_tol        = 1.0e-8 </code></pre><p>The parameters that are changed from the default settings are highlighted in blue (not visible on this markdown document, but visible in the REPL). </p><p>If you want to see what each of these parameters mean, you can get some basic help with:</p><pre><code class="language-julia hljs">help?&gt; Time
search: Time time Timer time_ns timedwait mtime ctime @time @timev @timed @time_imports @showtime optimize_ticks optimize_datetime_ticks Read_LaMEM_timestep

  Structure that contains the LaMEM timestepping information. An explanation of the paramneters is given in the struct `Time_info`
    •  time_end::Float64: simulation end time
    •  dt::Float64: initial time step
    •  dt_min::Float64: minimum time step (declare divergence if lower value is attempted)
    •  dt_max::Float64: maximum time step
    •  dt_out::Float64: output step (output at least at fixed time intervals)
    •  inc_dt::Float64: time step increment per time step (fraction of unit)
    •  CFL::Float64: CFL (Courant-Friedrichs-Lewy) criterion
    •  CFLMAX::Float64: CFL criterion for elasticity
    •  nstep_max::Int64: maximum allowed number of steps (lower bound: timeend/dtmax)
    •  nstep_out::Int64: save output every n steps; Set this to -1 to deactivate saving output
    •  nstep_rdb::Int64: save restart database every n steps
    •  num_dt_periods::Int64: number of time stepping periods
    •  time_dt_periods::Vector{Int64}: timestamps where timestep should be fixed (first entry has to 0)
    •  step_dt_periods::Vector{Float64}: target timesteps ar timestamps above
    •  nstep_ini::Int64: save output for n initial steps
    •  time_tol::Float64: relative tolerance for time comparisons</code></pre><p>If you want to change one of the parameters, say the maximum number of timesteps, you can do that with:</p><pre><code class="language-julia hljs">julia&gt; model.Time.nstep_max=100
100</code></pre><p>You can verify that this has been changed with:</p><pre><code class="language-julia hljs">julia&gt; model.Time
LaMEM Timestepping parameters: 
  time_end        = 1.0 
  dt              = 0.05 
  dt_min          = 0.01 
  dt_max          = 0.2 
  dt_out          = 0.2 
  inc_dt          = 0.1 
  CFL             = 0.5 
  CFLMAX          = 0.8 
  nstep_max       = 100 
  nstep_out       = 1 
  nstep_rdb       = 100 
  nstep_ini       = 1 
  time_tol        = 1.0e-8 </code></pre><h5 id="Set-timestepping-parameters"><a class="docs-heading-anchor" href="#Set-timestepping-parameters">Set timestepping parameters</a><a id="Set-timestepping-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Set-timestepping-parameters" title="Permalink"></a></h5><p>Ok, lets change a few parameters at the same time. Here the maximum time (<code>time_end</code>) is set to a large value (2000 Myrs) as we want to limit the simulation using <code>nstep_max = 400</code>, which implies that we will perform 400 timesteps</p><pre><code class="language-julia hljs">model.Time = Time(  time_end  = 2000.0,
                    dt        = 0.001,
                    dt_min    = 0.000001,
                    dt_max    = 0.1,
                    nstep_max = 400,
                    nstep_out = 10
                 )</code></pre><p>Note that you can achieve the same results with:</p><pre><code class="language-julia hljs">model.Time.time_end  = 2000.0
model.Time.dt  = 0.001
model.Time.dt_min  = 0.000001
model.Time.dt_max  = 0.1
model.Time.nstep_max  = 400
model.Time.nstep_out  = 10</code></pre><h5 id="Set-solution-parameters"><a class="docs-heading-anchor" href="#Set-solution-parameters">Set solution parameters</a><a id="Set-solution-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Set-solution-parameters" title="Permalink"></a></h5><p>We activate shear heating and adiabatic heating, as well as thermal diffusion, and set the minimum and maximum viscosities of the model as:</p><pre><code class="language-julia hljs">model.SolutionParams = SolutionParams(  shear_heat_eff = 1.0,
                                        Adiabatic_Heat = 1.0,
                                        act_temp_diff  = 1,
                                        eta_min   = 5e18,
                                        eta_ref   = 1e21,
                                        eta_max   = 1e25,
                                        min_cohes = 1e3
                                    )</code></pre><h5 id="Set-surface-topography"><a class="docs-heading-anchor" href="#Set-surface-topography">Set surface topography</a><a id="Set-surface-topography-1"></a><a class="docs-heading-anchor-permalink" href="#Set-surface-topography" title="Permalink"></a></h5><p>In our simulation, we want to take a free surface into account. In LaMEM that is done with a sticky air layer (phase 5 here), combined with a mesh that tracks the location of the free surface. You need to activate the free surface, tell LaMEM which phase is the sticky air phase and what the initial free surface level is at the beginning of the simulation (0 km). Do that with:</p><pre><code class="language-julia hljs">model.FreeSurface = FreeSurface(    surf_use        = 1,                # free surface activation flag
                                    surf_corr_phase = 1,                # air phase ratio correction flag (due to surface position)
                                    surf_level      = 0.0,              # initial level
                                    surf_air_phase  = 5,                # phase ID of sticky air layer
                                    surf_max_angle  = 40.0              # maximum angle with horizon (smoothed if larger))
                                )</code></pre><h5 id="Set-model-output"><a class="docs-heading-anchor" href="#Set-model-output">Set model output</a><a id="Set-model-output-1"></a><a class="docs-heading-anchor-permalink" href="#Set-model-output" title="Permalink"></a></h5><p>We update the list of fields saved as output:</p><pre><code class="language-julia hljs">model.Output = Output(  out_density         = 1,
                        out_j2_strain_rate  = 1,
                        out_surf            = 1, 	
                        out_surf_pvd        = 1,
                        out_surf_topography = 1,
                        out_j2_dev_stress   = 1,
                        out_pressure        = 1,
                        out_temperature     = 1,  )</code></pre><h5 id="Set-some-background-properties,-later-overwritten"><a class="docs-heading-anchor" href="#Set-some-background-properties,-later-overwritten">Set some background properties, later overwritten</a><a id="Set-some-background-properties,-later-overwritten-1"></a><a class="docs-heading-anchor-permalink" href="#Set-some-background-properties,-later-overwritten" title="Permalink"></a></h5><p>The model geometry in LaMEM is defined by two arrays: <code>model.Grid.Temp</code> and <code>model.Grid.Phase</code> which sets the initial temperature and phase at every point. These are 3D arrays that can be modified; in the usual case temperatures are assumed to be in Celcius, and the phases are integers (0-5 here).  </p><p>Lets specify a few helpful parameters, such as the adiabatic temperature throughout the model (0.4°C/km) and the mantle potential temperature at the surface 1280°C:</p><pre><code class="language-julia hljs">Tair            = 20.0;
Tmantle         = 1280.0;
Adiabat         = 0.4</code></pre><p>Next, we set the temperature everwhere to (will be overwrittem later) and all phases to 0 with</p><pre><code class="language-julia hljs">model.Grid.Temp     .= Tmantle .+ 1.0;      # set mantle temperature (without adiabat at first)
model.Grid.Phases   .= 0;                   # Set Phases to 0 everywhere (0 is/will be asthenosphere in this setup):</code></pre><h5 id="Setup-temperature-of-the-air-to-be-20C"><a class="docs-heading-anchor" href="#Setup-temperature-of-the-air-to-be-20C">Setup temperature of the air to be 20°C</a><a id="Setup-temperature-of-the-air-to-be-20C-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-temperature-of-the-air-to-be-20C" title="Permalink"></a></h5><p>Next we set all &quot;air&quot; particles to <code>Tair</code>: </p><pre><code class="language-julia hljs">model.Grid.Temp[model.Grid.Grid.Z .&gt; 0]    .=  Tair;</code></pre><p>We can quickly verify that this has been done on the <code>REPL</code> with:</p><pre><code class="language-julia hljs">julia&gt;julia&gt; model.Grid
LaMEM grid with constant Δ: 
  nel         : ([512], [1], [128])
  marker/cell : (3, 3, 3)
  x           ϵ [-2000.0 : 2000.0]
  y           ϵ [-8.0 : 8.0]
  z           ϵ [-660.0 : 40.0]
  Phases      : range ϵ [0 - 0]
  Temp        : range ϵ [20.0 - 1281.0]</code></pre><h5 id="Setup-the-air-layer-(id-5)-if-Z-0.0"><a class="docs-heading-anchor" href="#Setup-the-air-layer-(id-5)-if-Z-0.0">Setup the air layer (id = 5) if Z &gt; 0.0</a><a id="Setup-the-air-layer-(id-5)-if-Z-0.0-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-the-air-layer-(id-5)-if-Z-0.0" title="Permalink"></a></h5><p>Set the air particles to 5:</p><pre><code class="language-julia hljs">model.Grid.Phases[model.Grid.Grid.Z .&gt; 0.0 ] .= 5;</code></pre><h5 id="Add-left-oceanic-plate"><a class="docs-heading-anchor" href="#Add-left-oceanic-plate">Add left oceanic plate</a><a id="Add-left-oceanic-plate-1"></a><a class="docs-heading-anchor-permalink" href="#Add-left-oceanic-plate" title="Permalink"></a></h5><p>An oceanic plate can be added using the <code>AddBox!()</code> function of the <code>GeophysicalModelGenerator</code> package (see <code>?GeophysicalModelGenerator.AddBox!</code> for more information, or check out the online <a href="https://juliageodynamics.github.io/GeophysicalModelGenerator.jl/dev/man/lamem/">help</a> of the package). The lithosphere to asthenosphere temperature is set to 1250°C. If temperature of the plate is &gt; 1250°C then the material is turned to asthenosphere. The temperature profile of the plate is set using a half space cooling temperature and a spreading rate velocity of 0.5 cm/yr with the ridge prescribed to be at the &quot;left&quot; of the box.</p><pre><code class="language-julia hljs">AddBox!(model;  xlim    = (-2000.0, 0.0), 
                ylim    = (model.Grid.coord_y...,), 
                zlim    = (-660.0, 0.0),
                Origin  = nothing, StrikeAngle=0, DipAngle=0,
                phase   = LithosphericPhases(Layers=[20 80], Phases=[1 2 0] ),
                T       = SpreadingRateTemp(    Tsurface    = Tair,
                                                Tmantle     = Tmantle,
                                                MORside     = &quot;left&quot;,
                                                SpreadingVel= 0.5,
                                                AgeRidge    = 0.01;
                                                maxAge      = 80.0      ) )</code></pre><h5 id="Add-right-oceanic-plate"><a class="docs-heading-anchor" href="#Add-right-oceanic-plate">Add right oceanic plate</a><a id="Add-right-oceanic-plate-1"></a><a class="docs-heading-anchor-permalink" href="#Add-right-oceanic-plate" title="Permalink"></a></h5><p>Same for the plate on the right:</p><pre><code class="language-julia hljs">AddBox!(model;  xlim    = (1500, 2000), 
                ylim    = (model.Grid.coord_y..., ), 
                zlim    = (-660.0, 0.0),
                Origin  = nothing, StrikeAngle=0, DipAngle=0,
                phase   = LithosphericPhases(Layers=[20 80], Phases=[1 2 0] ),
                T       = SpreadingRateTemp(    Tsurface    = Tair,
                                                Tmantle     = Tmantle,
                                                MORside     = &quot;right&quot;,
                                                SpreadingVel= 0.5,
                                                AgeRidge    = 0.01;
                                                maxAge      = 80.0      ) )</code></pre><h5 id="Add-overriding-plate-margin"><a class="docs-heading-anchor" href="#Add-overriding-plate-margin">Add overriding plate margin</a><a id="Add-overriding-plate-margin-1"></a><a class="docs-heading-anchor-permalink" href="#Add-overriding-plate-margin" title="Permalink"></a></h5><p>For the overriding plate margin the age is fixed to 90 Ma using <code>HalfspaceCoolingTemp()</code>.</p><pre><code class="language-julia hljs">AddBox!(model;  xlim    = (0.0, 400.0), 
                ylim    = (model.Grid.coord_y[1], model.Grid.coord_y[2]), 
                zlim    = (-660.0, 0.0),
                Origin  = nothing, StrikeAngle=0, DipAngle=0,
                phase   = LithosphericPhases(Layers=[25 90], Phases=[3 4 0] ),
                T       = HalfspaceCoolingTemp(     Tsurface    = Tair,
                                                    Tmantle     = Tmantle,
                                                    Age         = 80      ) )</code></pre><h5 id="Add-overriding-plate-craton"><a class="docs-heading-anchor" href="#Add-overriding-plate-craton">Add overriding plate craton</a><a id="Add-overriding-plate-craton-1"></a><a class="docs-heading-anchor-permalink" href="#Add-overriding-plate-craton" title="Permalink"></a></h5><pre><code class="language-julia hljs">AddBox!(model;  xlim    = (400.0, 1500.0), 
                ylim    = (model.Grid.coord_y...,), 
                zlim    = (-660.0, 0.0),
                Origin  = nothing, StrikeAngle=0, DipAngle=0,
                phase   = LithosphericPhases(Layers=[35 100], Phases=[3 4 0] ),
                T       = HalfspaceCoolingTemp(     Tsurface    = Tair,
                                                    Tmantle     = Tmantle,
                                                    Age         = 120      ) )</code></pre><h5 id="Add-pre-subducted-slab"><a class="docs-heading-anchor" href="#Add-pre-subducted-slab">Add pre-subducted slab</a><a id="Add-pre-subducted-slab-1"></a><a class="docs-heading-anchor-permalink" href="#Add-pre-subducted-slab" title="Permalink"></a></h5><p>Here we change the dip angle of the box to 30° to initiates subduction:</p><pre><code class="language-julia hljs">AddBox!(model;  xlim    = (0.0, 300), 
                ylim    = (model.Grid.coord_y...,), 
                zlim    = (-660.0, 0.0),
                Origin  = nothing, StrikeAngle=0, DipAngle=30,
                phase   = LithosphericPhases(Layers=[30 80], Phases=[1 2 0], Tlab=1250 ),
                T       = HalfspaceCoolingTemp(     Tsurface    = Tair,
                                                    Tmantle     = Tmantle,
                                                    Age         = 80      ) )</code></pre><h5 id="Impose-approximate-adiabat"><a class="docs-heading-anchor" href="#Impose-approximate-adiabat">Impose approximate adiabat</a><a id="Impose-approximate-adiabat-1"></a><a class="docs-heading-anchor-permalink" href="#Impose-approximate-adiabat" title="Permalink"></a></h5><p>We can add a mantle adiabatic temperature to the model with</p><pre><code class="language-julia hljs">model.Grid.Temp = model.Grid.Temp - model.Grid.Grid.Z.*Adiabat;</code></pre><h5 id="Plot-preview-of-the-setup"><a class="docs-heading-anchor" href="#Plot-preview-of-the-setup">Plot preview of the setup</a><a id="Plot-preview-of-the-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-preview-of-the-setup" title="Permalink"></a></h5><p>Cross-sections of the model setup showing the temperature and the phase fields can be visualized as follows:</p><pre><code class="language-julia hljs">plot_cross_section(model, y=0, field=:temperature)
plot_cross_section(model, y=0, field=:phase)</code></pre><p>which gives:  <img src="../sub_field.png" alt="Subduction_CrossSection"/>  <img src="../sub_temp.png" alt="Subduction_CrossSection"/></p><h4 id=".-Define-material-parameters"><a class="docs-heading-anchor" href="#.-Define-material-parameters">3. Define material parameters</a><a id=".-Define-material-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#.-Define-material-parameters" title="Permalink"></a></h4><p>At this stage, we defined the geometry and thermal structures of the model, but we did yet assign material properties to each of the rocktypes.</p><h5 id="Softening-law"><a class="docs-heading-anchor" href="#Softening-law">Softening law</a><a id="Softening-law-1"></a><a class="docs-heading-anchor-permalink" href="#Softening-law" title="Permalink"></a></h5><p>We assume that rocks weaken/soften when they becomes damaged, which can be defined by a softening law. Post-softening strength is defined as 0.05 the initial strength</p><pre><code class="language-julia hljs">softening =       Softening(    ID   = 0,   			# softening law ID
                                APS1 = 0.1, 			# begin of softening APS
                                APS2 = 0.5, 			# end of softening APS
                                A    = 0.95, 		        # reduction ratio
                            )</code></pre><h5 id="Material-thermal-and-rheological-properties"><a class="docs-heading-anchor" href="#Material-thermal-and-rheological-properties">Material thermal and rheological properties</a><a id="Material-thermal-and-rheological-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Material-thermal-and-rheological-properties" title="Permalink"></a></h5><p><em>Mantle</em> For the mantle, we use a dry olivine rheology:</p><pre><code class="language-julia hljs">dryPeridotite = Phase(  Name        = &quot;dryPeridotite&quot;,                                     
                        ID          = 0,                                                # phase id  [-]
                        rho         = 3300.0,                                           # density [kg/m3]
                        alpha       = 3e-5,                                             # coeff. of thermal expansion [1/K]
                        disl_prof   = &quot;Dry_Olivine_disl_creep-Hirth_Kohlstedt_2003&quot;,
                        Vn          = 14.5e-6,
                        diff_prof   = &quot;Dry_Olivine_diff_creep-Hirth_Kohlstedt_2003&quot;,
                        Vd          = 14.5e-6,
                        G           = 5e10,                                             # elastic shear module [MPa]
                        k           = 3,                                                # conductivity
                        Cp          = 1000.0,                                           # heat capacity
                        ch          = 30e6,                                             # cohesion [Pa]
                        fr          = 20.0,                                             # friction angle	
                        A           = 6.6667e-12,                                       # radiogenic heat production [W/kg]
                        chSoftID    = 0,      	                                        # cohesion softening law ID
                        frSoftID    = 0,      	                                        # friction softening law ID
                        )</code></pre><p><em>Oceanic crust</em> For the oceanic crust we use a low cohesion and a frictional angle equal to 0. The goal is to make the oceanic crust weak enough to lubricate the interface with the overriding plate and allow for self-sustained subduction. Moreover, as density is not pressure and temperature dependent, it is set to be the same as the mantle (3300) in order to be neutrally buoyant with respect to the rest of the lithosphere.</p><pre><code class="language-julia hljs">oceanicCrust = Phase(   Name        = &quot;oceanCrust&quot;,                                     
                        ID          = 1,                                                # phase id  [-]
                        rho         = 3300.0,                                           # density [kg/m3]
                        alpha       = 3e-5,                                             # coeff. of thermal expansion [1/K]
                        disl_prof   = &quot;Plagioclase_An75-Ranalli_1995&quot;,
                        G           = 5e10,                                             # elastic shear module [MPa]
                        k           = 3,                                                # conductivity
                        Cp          = 1000.0,                                           # heat capacity
                        ch          = 5e6,                                              # cohesion [Pa]
                        fr          = 0.0,                                              # friction angle	
                        A           = 2.333e-10,                                        # radiogenic heat production [W/kg]
                     )</code></pre><p><em>Oceanic mantle lithosphere</em> The oceanic mantle lithosphere has the same properties as the mantle but a different name and different phase. To simplify your life, you can use the <code>copy_phase</code> function for that:</p><pre><code class="language-julia hljs">oceanicLithosphere = copy_phase(    dryPeridotite,
                                    Name            = &quot;oceanicLithosphere&quot;,
                                    ID              = 2
                                )</code></pre><p><em>Continental crust</em></p><pre><code class="language-julia hljs">continentalCrust = copy_phase(      oceanicCrust,
                                    Name            = &quot;continentalCrust&quot;,
                                    ID              = 3,
                                    disl_prof       = &quot;Quarzite-Ranalli_1995&quot;,
                                    rho             = 2700.0,  
                                    ch              = 30e6,
                                    fr              = 20.0,
                                    A         	    = 5.3571e-10,
                                    chSoftID  	    = 0,      	                                        
                                    frSoftID  	    = 0,      	                                        
                             )</code></pre><p><em>Continental lithosphere</em></p><pre><code class="language-julia hljs">continentalLithosphere = copy_phase(    dryPeridotite,
                                        Name            = &quot;continentalLithosphere&quot;,
                                        ID              = 4
                                )</code></pre><p><em>Sticky air</em> Finally, the &quot;air&quot; in our model is a layer with low density and low viscosity, such that it essentially gives very low stresses compared to those within the lithosphere. We cannot give it the viscosity of real air, as this results in a too large viscosity jump at the surface (geodynamic codes cannot handle that). We therefore also often call this &quot;sticky air&quot;. Note that we also give it a very high thermal conductivity to ensure that the temperature within the air layer remains more or less constant throughout a simulation (and equal to the temperature at the upper boundary of the model):</p><pre><code class="language-julia hljs">air         = Phase(    Name        = &quot;air&quot;,                                     
                        ID          = 5,                                                # phase id  [-]
                        rho         = 50.0,                                             # density [kg/m3]                                           # coeff. of thermal expansion [1/K]
                        eta         = 1e19,
                        G           = 5e10,                                             # elastic shear module [MPa]
                        k           = 100,                                              # conductivity
                        Cp          = 1e6,                                              # heat capacity
                        ch          = 10e6,                                             # cohesion [MPa]
                        fr          = 0.0,                                              # friction angle	
                    )</code></pre><h5 id="Add-phases-to-the-model"><a class="docs-heading-anchor" href="#Add-phases-to-the-model">Add phases to the model</a><a id="Add-phases-to-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Add-phases-to-the-model" title="Permalink"></a></h5><p>Finally, we can add all these phases to the model with:</p><pre><code class="language-julia hljs">rm_phase!(model)
add_phase!( model, 
            dryPeridotite,
            oceanicCrust,
            oceanicLithosphere,
            continentalCrust,
            continentalLithosphere,
            air
          )</code></pre><h5 id="Add-softening-law"><a class="docs-heading-anchor" href="#Add-softening-law">Add softening law</a><a id="Add-softening-law-1"></a><a class="docs-heading-anchor-permalink" href="#Add-softening-law" title="Permalink"></a></h5><p>Same with the softening law:</p><pre><code class="language-julia hljs">add_softening!( model,
                softening
                )</code></pre><h5 id="Set-solver-options"><a class="docs-heading-anchor" href="#Set-solver-options">Set solver options</a><a id="Set-solver-options-1"></a><a class="docs-heading-anchor-permalink" href="#Set-solver-options" title="Permalink"></a></h5><p>The PETSc command <code>-da_refine_y 1</code> allow to run the model as 2D</p><pre><code class="language-julia hljs">model.Solver = Solver(  SolverType      = &quot;multigrid&quot;,
                        MGLevels        = 3,
                        MGCoarseSolver 	= &quot;superlu_dist&quot;,
                        PETSc_options   = [ &quot;-snes_ksp_ew&quot;,
                                            &quot;-snes_ksp_ew_rtolmax 1e-4&quot;,
                                            &quot;-snes_rtol 5e-3&quot;,			
                                            &quot;-snes_atol 1e-4&quot;,
                                            &quot;-snes_max_it 200&quot;,
                                            &quot;-snes_PicardSwitchToNewton_rtol 1e-3&quot;, 
                                            &quot;-snes_NewtonSwitchToPicard_it 20&quot;,
                                            &quot;-js_ksp_type fgmres&quot;,
                                            &quot;-js_ksp_max_it 20&quot;,
                                            &quot;-js_ksp_atol 1e-8&quot;,
                                            &quot;-js_ksp_rtol 1e-4&quot;,
                                            &quot;-snes_linesearch_type l2&quot;,
                                            &quot;-snes_linesearch_maxstep 10&quot;,
                                            &quot;-da_refine_y 1&quot;
                                        ]
                    )</code></pre><h4 id=".-Perform-the-simulation"><a class="docs-heading-anchor" href="#.-Perform-the-simulation">4. Perform the simulation</a><a id=".-Perform-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#.-Perform-the-simulation" title="Permalink"></a></h4><p>Here we run LaMEM on 8 cores (if you have them; use less otherwise):</p><pre><code class="language-julia hljs">julia&gt; run_lamem(model, 8)
Saved file: Model3D.vts
(Nprocx, Nprocy, Nprocz, xc, yc, zc, nNodeX, nNodeY, nNodeZ) = (4, 1, 2, [-2000.0, -1000.0, 0.0, 1000.0, 2000.0], [-8.0, 8.0], [-660.0, -310.0, 40.0], 513, 2, 129)
Writing LaMEM marker file -&gt; ./markers/mdb.00000000.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000001.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000002.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000003.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000004.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000005.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000006.dat
Writing LaMEM marker file -&gt; ./markers/mdb.00000007.dat
-------------------------------------------------------------------------- 
                   Lithosphere and Mantle Evolution Model                   
     Compiled: Date: Apr  7 2023 - Time: 22:11:23           
     Version : 1.2.4 
-------------------------------------------------------------------------- 
        STAGGERED-GRID FINITE DIFFERENCE CANONICAL IMPLEMENTATION           
-------------------------------------------------------------------------- 
Parsing input file : output.dat 
Finished parsing input file : output.dat 
--------------------------------------------------------------------------
Scaling parameters:
   Temperature : 1000. [C/K] 
   Length      : 1000. [m] 
   Viscosity   : 1e+20 [Pa*s] 
   Stress      : 1e+09 [Pa] </code></pre><p>The results will be saved in the directory where you performed the simulation and can be visualized in Paraview by opening the file <code>output.pvd</code>:  <img src="../subduction_ts25.png" alt="2D thermomechanical subduction"/></p><h5 id="Remark-on-performing-parallel-simulations"><a class="docs-heading-anchor" href="#Remark-on-performing-parallel-simulations">Remark on performing parallel simulations</a><a id="Remark-on-performing-parallel-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Remark-on-performing-parallel-simulations" title="Permalink"></a></h5><p>Using more processors or cores does not necessarily imply that the simulation will be faster. There is a tradeoff between the number of processors, the resolution, the number of multigrid levels, the machine you use and the speed of the simulation. At some stage it actually becomes slower! </p><p>Unfortunately, it is hard to predict when this happens as this is setup- and machine-dependent. We can thus not automatize this, and our recommendation is therefore that you experiment with this. Run the simulation for a limited number of timesteps (say 5 or so) and check its speed for different number of cores.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../juliasetup_LaPalma/">« Example 2: Volcano</a><a class="docs-footer-nextpage" href="../juliasetup_pluto/">Notebooks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 27 November 2023 22:38">Monday 27 November 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
